option java_package = "com.splicemachine.coprocessor";
option java_outer_classname = "SpliceMessage";
option java_generic_services = true;
option java_generate_equals_and_hash = true;
option optimize_for = SPEED;

import "Client.proto";

message TaskStats {
	optional uint64 totalTime = 1;
	optional uint64 totalRowsProcessed = 2;
	optional uint64 totalRowsWritten = 3;
}

message SpliceObserverInstructions {
	bytes bytes = 1;	
}


message SpliceOperationRequest {
	optional Scan scan = 1;
	optional SpliceObserverInstructions soi = 2;
}

message SpliceSchedulerRequest {
	optional bytes taskStart = 1;
	optional bytes taskEnd = 2;
	optional className = 3;
	optional classBytes = 4;
}

message SpliceSchedulerResponse {
	optional string taskNode = 1;
	optional bytes taskId = 2;
	optional double estimatedCost = 3;
}

message DeleteFirstAfterRequest{
	optional string transactionId = 1;
	optional bytes rowKey = 2;
	optional bytes limit = 3;
}

message WriteResult {

}


message BulkWriteResponse {
	optional bytes bytes = 1;
}

message BulkWriteRequest {
	optional bytes bytes = 1;
}

message DropIndexRequest {
	optional uint64 indexConglomId = 1;
	optional uint64 baseConglomId = 2;
}

message DropIndexResponse {
}


service SpliceIndexService {
	rpc bulkWrite(BulkWriteRequest)
	  returns (BulkWriteResponse);
	rpc deleteFirstAfter(DeleteFirstAfterRequest)
	  returns (WriteResult); 
}

service SpliceIndexManagementService {
	rpc dropIndex(DropIndexRequest) 
	  returns (DropIndexResponse);	
}

service SpliceOperationService {
	rpc run(SpliceOperationRequest)
	  returns (TaskStats);
}

service SpliceSchedulerService {
	rpc submit(SpliceSchedulerRequest)
	  returns (SpliceSchedulerResponse);
}

service SpliceDerbyCoprocessorService {

}



