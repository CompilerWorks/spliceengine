package com.splicemachine.derby.impl.sql.execute.operations;

import java.sql.SQLWarning;
import java.sql.Timestamp;

import org.apache.derby.iapi.error.StandardException;
import org.apache.derby.iapi.reference.SQLState;
import org.apache.derby.iapi.sql.Activation;
import org.apache.derby.iapi.sql.ResultDescription;
import org.apache.derby.iapi.sql.ResultSet;
import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
import org.apache.derby.iapi.sql.conn.StatementContext;
import org.apache.derby.iapi.sql.execute.ExecRow;
import org.apache.derby.iapi.sql.execute.NoPutResultSet;
import org.apache.derby.iapi.types.DataValueDescriptor;
import org.apache.log4j.Logger;

import com.splicemachine.utils.SpliceLogUtils;

public abstract class NoRowsResultSetOperation implements ResultSet {
	private static Logger LOG = Logger.getLogger(NoRowsResultSetOperation.class);
	final Activation    activation;
    private NoPutResultSet[] subqueryTrackingArray;
	/** True if the result set has been opened, and not yet closed. */
	private boolean isOpen;
	/* Run time statistics variables */
	final LanguageConnectionContext lcc;
	protected long beginTime;
	protected long endTime;
	protected long beginExecutionTime;
	protected long endExecutionTime;

    private int                             firstColumn = -1;    // First column being stuffed. For UPDATES, this lies in the second half of the row.
    private int[]                           generatedColumnPositions; // 1-based positions of generated columns in the target row

    // One cell for  each slot in generatedColumnPositions. These are temporary
    // values which hold the result of running the generation clause before we
    // stuff the result into the target row.
    private DataValueDescriptor[]  normalizedGeneratedValues;
    
    
	public NoRowsResultSetOperation(Activation activation) {
		this.activation = activation;
		lcc = activation.getLanguageConnectionContext();
	}
	
	public final boolean returnsRows() { return false; }
	public int	modifiedRowCount() { return 0; }
	public final Activation getActivation() {
		SpliceLogUtils.trace(LOG, "getActivation");
		return activation;
	}
	
	public void addWarning(SQLWarning w) {
        // We're not returning a (JDBC) ResultSet, so add the warning to
        // the Activation so that it's included in the warning chain of the
        // executing Statement.
        getActivation().addWarning(w);
    }
	
	public SQLWarning getWarnings() {
		return null;
	}
	
	public final ExecRow	getAbsoluteRow(int row) throws StandardException
	{
		/*
			The JDBC use of this class will never call here.
			Only the DB API used directly can get this exception.
		 */
		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "absolute");
	}

	public ResultSet getAutoGeneratedKeysResultset()
	{
		//A non-null resultset would be returned only for an insert statement 
		return (ResultSet)null;
	}
	
	public void	finish() throws StandardException
	{
	}
	
	public long getExecuteTime()
	{
		return endTime - beginTime;
	}
	
	public Timestamp getBeginExecutionTimestamp()
	{
		if (beginExecutionTime == 0)
		{
			return null;
		}
		else
		{
			return new Timestamp(beginExecutionTime);
		}
	}
	
	public Timestamp getEndExecutionTimestamp()
	{
		if (endExecutionTime == 0)
		{
			return null;
		}
		else
		{
			return new Timestamp(endExecutionTime);
		}
	}
	
	public long getTimeSpent(int type)
	{
		/* RESOLVE - this should be overloaded in all subclasses */
		return 0;
	}
	
	public String getCursorName() {
		return null;
	}
	
	public final ExecRow	getRelativeRow(int row) throws StandardException
	{
		/*
			The JDBC use of this class will never call here.
			Only the DB API used directly can get this exception.
		 */
		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "relative");
	}

	public final ExecRow	setBeforeFirstRow() 
		throws StandardException
	{
		/*
			The JDBC use of this class will never call here.
			Only the DB API used directly can get this exception.
		 */
		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "beforeFirst");
	}

	public final ExecRow	getFirstRow() 
		throws StandardException
	{
		/*
			The JDBC use of this class will never call here.
			Only the DB API used directly can get this exception.
		 */
		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "first");
	}

	public final ExecRow	getNextRow() throws StandardException
	{
		/*
			The JDBC use of this class will never call here.
			Only the DB API used directly can get this exception.
		 */
		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "next");
	}

	public final ExecRow	getPreviousRow() 
		throws StandardException
	{
		/*
			The JDBC use of this class will never call here.
			Only the DB API used directly can get this exception.
		 */
		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "previous");
	}

	public final ExecRow	getLastRow()
		throws StandardException
	{
		/*
			The JDBC use of this class will never call here.
			Only the DB API used directly can get this exception.
		 */
		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "last");
	}

	public final ExecRow	setAfterLastRow() 
		throws StandardException
	{
		/*
			The JDBC use of this class will never call here.
			Only the DB API used directly can get this exception.
		 */
		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "afterLast");
	}
	
	public final void clearCurrentRow() 
	{
		
	}

    public final boolean checkRowPosition(int isType)
	{
		return false;
	}

	public final int getRowNumber()
	{
		return 0;
	}
	
	public void	close() throws StandardException
	{ 
		if (!isOpen)
			return;

		/* This is the top ResultSet, 
		 * close all of the open subqueries.
		 */
		int staLength = (subqueryTrackingArray == null) ? 0 :
							subqueryTrackingArray.length;

		for (int index = 0; index < staLength; index++)
		{
			if (subqueryTrackingArray[index] == null)
			{
				continue;
			}
			if (subqueryTrackingArray[index].isClosed())
			{
				continue;
			}
			subqueryTrackingArray[index].close();
		}

		isOpen = false;

		if (activation.isSingleExecution())
			activation.close();
	}
	
	public final NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
	{
		if (subqueryTrackingArray == null)
		{
			subqueryTrackingArray = new NoPutResultSet[numSubqueries];
		}

		return subqueryTrackingArray;
	}
	
	public ResultDescription	getResultDescription()
	{
	    return (ResultDescription)null;
	}
	
	public boolean isClosed() {
		return !isOpen;
	}
	
	void setup() throws StandardException {
		isOpen = true;

        StatementContext sc = lcc.getStatementContext();
        sc.setTopResultSet(this, subqueryTrackingArray);

        // Pick up any materialized subqueries
        if (subqueryTrackingArray == null) {
            subqueryTrackingArray = sc.getSubqueryTrackingArray();
        }
	}
}
