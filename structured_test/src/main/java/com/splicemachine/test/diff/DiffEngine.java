package com.splicemachine.test.diff;

import com.splicemachine.test.nist.NistTestUtils;
import difflib.DiffUtils;
import difflib.Patch;
import difflib.StringUtills;
import difflib.myers.Equalizer;
import org.apache.derby.iapi.util.StringUtil;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Static utility to determine and report file differences
 */
public class DiffEngine {

    /**
     * Calculate the differences of the output generated by all the given SQL scripts.
     * @param sqlFiles SQL script files that were executed against Derby and Splice
     *                 to produce output residing in <code>testOutputDir</code>
     * @param testOutputDir the directory in which to look for SQL script output
     * @param derbyFilter any optional output line filters to apply to Derby output.
     * @param spliceFilter any optional output line filters to apply to Splice output.
     * @return the list of {@link DiffReport}s
     */
    public static List<DiffReport> diffOutput(List<File> sqlFiles,
                                              String testOutputDir,
                                              List<String> derbyFilter,
                                              List<String> spliceFilter) {

        List<DiffReport> diffs = new ArrayList<DiffReport>();

        String inputDir = NistTestUtils.getBaseDirectory() + NistTestUtils.TARGET_NIST_DIR;
        if (testOutputDir != null && ! testOutputDir.isEmpty()) {
            inputDir = testOutputDir;
        }
        for (File sqlFile: sqlFiles) {
            // derby output
            String derbyFileName = inputDir + sqlFile.getName().replace(".sql", NistTestUtils.DERBY_OUTPUT_EXT);
            // NOTE: the "--" comment pattern also removes formatted output lines with only dashes
            List<String> derbyFileLines = NistTestUtils.fileToLines(derbyFileName, "--", "ij> --");
            // filter derby warnings, etc
            derbyFileLines = filterOutput(derbyFileLines, derbyFilter);

            // splice output
            String spliceFileName = inputDir + sqlFile.getName().replace(".sql", NistTestUtils.SPLICE_OUTPUT_EXT);
            // NOTE: the "--" comment pattern also removes formatted output lines with only dashes
            List<String> spliceFileLines = NistTestUtils.fileToLines(spliceFileName, "--", "ij> --");
            // filter splice warnings, etc
            spliceFileLines = filterOutput(spliceFileLines, spliceFilter);

            Patch patch = DiffUtils.diff(derbyFileLines, spliceFileLines, new NistLineEqualizer());

            DiffReport diff = new DiffReport(derbyFileName, spliceFileName, patch.getDeltas());
            diffs.add(diff);
        }
        return diffs;
    }

    /**
     * Remove (filter) any lines in <code>fileLines</code> that contain any occurrences of
     * <code>lineFilters</code>
     * @param fileLines the strings to consider
     * @param lineFilters patterns, occurrences of which, should be filtered.
     * @return the result of the <code>fileLines</code> filtering (lines with lineFilters
     * removed).
     */
    public static List<String> filterOutput(List<String> fileLines, List<String> lineFilters) {
        if (fileLines == null || fileLines.isEmpty()) {
            return fileLines;
        }
        List<String> copy = Collections.synchronizedList(new ArrayList<String>(fileLines));
        List<String> filteredLines = Collections.synchronizedList(new ArrayList<String>(fileLines.size()));
        for (String line : copy) {
            boolean filter = false;

            if (line.startsWith("CONNECTION")) {
                continue;
            }

            for (String warning : lineFilters) {
                if (line.contains(warning)) {
                    filter = true;
                    break;
                }
            }
            if (! filter) {
                filteredLines.add(line);
            }
        }
        return filteredLines;
    }

    private static class NistLineEqualizer implements Equalizer<String> {
        private static final String CONSTRAINT_ERROR = "ERROR X0Y44: Constraint 'SQL";
        @Override
        public boolean equals(String derby, String splice) {
            String derbyTrimmed = derby.trim();
            String spliceTrimmed = splice.trim();
            if (derbyTrimmed.startsWith(CONSTRAINT_ERROR) &&
                    spliceTrimmed.startsWith(CONSTRAINT_ERROR)) {
                // Not a bug, chars appearing after "SQL" are a conglomerate ID - different for each DB instance
                return true;
            } else if(derbyTrimmed.contains("|") && spliceTrimmed.contains("|")) {
                // Case where formatted output is formatted differently by Derby and Splice:
                //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                //Users/jeff/dev/spliceengine/structured_test/target/nist/dml130.derby
                //Position 79:
                //  [1               |NU&|NUM1C3]
                //  [0.00            |0  |0     ]
                //++++++++++++++++++++++++++
                //Users/jeff/dev/spliceengine/structured_test/target/nist/dml130.splice
                //Position 79:
                //  [1              |NU&|NUM1C3]
                //  [0.00           |0  |0     ]
                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                // Compare all non-whitespace tokens
                return equalsIgnoreWhitespace(derbyTrimmed, spliceTrimmed);
            } else {
                return derbyTrimmed.equals(spliceTrimmed);
            }
        }

        private static boolean equalsIgnoreWhitespace(String derby, String splice) {
            String[] derbyTokens = StringUtil.split(derby, ' ');
            String[] spliceTokens = StringUtil.split(splice, ' ');
            if (derbyTokens.length != spliceTokens.length) {
                return false;
            } else {
                int i = 0;
                while (i < derbyTokens.length) {
                    if (! derbyTokens[i].equals(spliceTokens[i])) {
                        return false;
                    }
                    ++i;
                }
            }
            return true;
        }
    }
}
